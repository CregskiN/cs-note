# 高级 GLSL

内建变量 Build-in Variable

Uniform 缓冲对象 Uniform Buffer Object

# GLSL 内建变量

## Vertex Shader 变量

+ `gl_Position` 只写输出变量。裁剪空间输出位置向量（MPV 变换后的位置）

+ `gl_PointSize` 只写输出变量。设置渲染图元点的大小 float

  ```c++
  // opengl
  glEnable(GL_PROGEAM_POINT_SIZE); // 启用在vs中设置point size 的功能
  glDrawArrays(GL_POINT, 0, 36); // 设置图元为点
  
  // .vert
  void main() {
      gl_Position = projection * view * model * vec4(aPos, 1.0);    
      gl_PointSize = gl_Position.z;
  }
  ```

+ `gl_VertexID` 只读输入变量。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。



## Fragment Shader 变量

+ gl_FragCoord
+ gl_FrontFacing
+ gl_FragDepth
+ 深度条件



`gl_FragCoord` 只读。为当前 fragment 在屏幕中的 xy 坐标（原点为屏幕左下角）和 z 深度

+ 可用于同一场景下，左右屏分模式渲染

  ```glsl
  void main()
  {             
      if(gl_FragCoord.x < 400)
          FragColor = vec4(1.0, 0.0, 0.0, 1.0);
      else
          FragColor = vec4(0.0, 1.0, 0.0, 1.0);        
  }
  ```

  <img src="https://www.qiniu.cregskin.com/202203210951583.png" alt="image-20220321095145447" style="zoom:33%;" /> 

  

  

`gl_FrontFacing` 只读。当不使用面剔除时，从这个 bool 变量能读取到当前 fragment 属于正面还是背面

+ 可用于立方体内外部，应用不同的纹理

  ```glsl
  #version 330 core
  out vec4 FragColor;
  
  in vec2 TexCoords;
  
  uniform sampler2D frontTexture;
  uniform sampler2D backTexture;
  
  void main()
  {             
      if(gl_FrontFacing)
          FragColor = texture(frontTexture, TexCoords);
      else
          FragColor = texture(backTexture, TexCoords);
  }
  ```

  

  

`gl_FragDepth` 可写输出变量。修改 fragement 的深度 z

+ 如果用户用 gl_FragDepth 修改深度值，则会导致**提前深度测试(Early Depth Testing)**不可用
+ 一种中和办法是，在OpenGL4.2之后， .frag 中使用**深度条件(Depth Condition)**

```glsl
layout (depth_<condition>) out float gl_FragDepth;
```

`condition`可以为下面的值：

| 条件        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| `any`       | 默认值。提前深度测试是禁用的，你会损失很多性能               |
| `greater`   | 你只能让深度值比`gl_FragCoord.z`更大                         |
| `less`      | 你只能让深度值比`gl_FragCoord.z`更小                         |
| `unchanged` | 如果你要写入`gl_FragDepth`，你将只能写入`gl_FragCoord.z`的值 |

```glsl
#version 420 core // 注意GLSL的版本！
out vec4 FragColor;
layout (depth_greater) out float gl_FragDepth;

void main()
{             
    FragColor = vec4(1.0);
    gl_FragDepth = gl_FragCoord.z + 0.1;
}
```





# 接口块 Interface Block

```glsl
// .vert
out VS_OUT
{
    vec2 TexCoords;
} vs_out;

// .frag
in VS_OUT
{
    vec2 TexCoords;
} fs_in;
```



# Uniform Block 布局

## std140

每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量**必须**等于基准对齐量的倍数。

GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个`N`来表示。

| 类型                | 布局规则                                                     |
| ------------------- | ------------------------------------------------------------ |
| 标量，比如int和bool | 每个标量的基准对齐量为N。                                    |
| 向量                | 2N或者4N。这意味着vec3的基准对齐量为4N。                     |
| 标量或向量的数组    | 每个元素的基准对齐量与vec4的相同。                           |
| 矩阵                | 储存为列向量的数组，每个向量的基准对齐量与vec4的相同。       |
| 结构体              | 等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。 |

```glsl
layout (std140) uniform ExampleBlock
{
                     // 基准对齐量       // 对齐偏移量
    float value;     // 4               // 0 
    vec3 vector;     // 16              // 16  (必须是16的倍数，所以 4->16)
    mat4 matrix;     // 16              // 32  (列 0)
                     // 16              // 48  (列 1)
                     // 16              // 64  (列 2)
                     // 16              // 80  (列 3)
    float values[3]; // 16              // 96  (values[0])
                     // 16              // 112 (values[1])
                     // 16              // 128 (values[2])
    bool boolean;    // 4               // 144
    int integer;     // 4               // 148
}; 
```

## shared、packed





## 使用 uniform buffer object

<img src="https://www.qiniu.cregskin.com/202203211107431.png" alt="image-20220321110714397" style="zoom:50%;" />

```c++
// 获取 shader 中 unifrom block 的 index
unsigned int uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, "Matrices");
unsigned int uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, "Matrices");
unsigned int uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, "Matrices");
unsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, "Matrices");
// shader.uniformBlock -> 0
glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, 0);
glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, 0);
glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, 0);
glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 0);

// 创建 unifrom buffer object
unsigned int uboMatrices;
glGenBuffers(1, &uboMatrices);
glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW);
glBindBuffer(GL_UNIFORM_BUFFER, 0);
// 将创建的 ubo 中 [0, 2*sizeof(glm::mat4)] 绑定到 0
glBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrices, 0, 2 * sizeof(glm::mat4));
// 或将整个 ubo 绑定到 0
glBindBufferBase(GL_UNIFORM_BUFFER, 0, uboMatrices)

// 往 ubo 填充数据
glm::mat4 projection = glm::perspective(45.0f, (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection));
glBindBuffer(GL_UNIFORM_BUFFER, 0);
```



























