顺序：Fragment Shader > Stencil Test > Depth Test

# 深度测试

将重叠的 fragment 分出前后，仅留下一层能渲染到屏幕上的

```c++

// 设置深度测试函数
glDepthFunc(GL_LESS);
```



| 函数        | 描述                                         |
| ----------- | -------------------------------------------- |
| GL_ALWAYS   | 永远通过深度测试                             |
| GL_NEVER    | 永远不通过深度测试                           |
| GL_LESS     | 在片段深度值小于缓冲的深度值时通过测试       |
| GL_EQUAL    | 在片段深度值等于缓冲区的深度值时通过测试     |
| GL_LEQUAL   | 在片段深度值小于等于缓冲区的深度值时通过测试 |
| GL_GREATER  | 在片段深度值大于缓冲区的深度值时通过测试     |
| GL_NOTEQUAL | 在片段深度值不等于缓冲区的深度值时通过测试   |
| GL_GEQUAL   | 在片段深度值大于等于缓冲区的深度值时通过测试 |



## 深度冲突

两个平面叠加的部分，难以计算具体谁在前谁在后，出现：

<img src="https://www.qiniu.cregskin.com/202203172218957.png" alt="image-20220317221806889" style="zoom:50%;" />

解决办法：

+ **在重叠部分，添加一个无法感知到的偏移值**。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。

+ 第二个技巧是**尽可能将近平面设置远一些**。在前面我们提到了精度在靠近**近**平面时是非常高的，所以如果我们将**近**平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的**近**平面距离。

+ 另外一个很好的技巧是牺牲一些性能，**使用更高精度的深度缓冲**。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。



# 模版缓冲

效果类似蒙版，丢弃一部分经过深度测试的 fragment（像素）

```c++
// 启用 stencil test
glEnable(GL_STENCIL_TEST);
// 清除 stencil buffer
glClear(GL_STENCIL_BUFFER_BIT);
// 设置模版掩码 // 在模版测试最后阶段，会将缓冲位与该掩码做 AND
glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样
glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）
```

## 模版函数 Stencil Test Function

```c++
// 控制模版测试的成败
glStencilFunc(GLenum func, GLint ref, GLuint mask)
```

- `func`：设置模板测试函数。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的`ref`值上。可用的选项与深度测试一样
- `ref`：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。
- `mask`：设置一个掩码，在 ref 与 stencil buffer 值比较之前，与 stencil buffer 进行 AND 运算

| 函数        | 描述                                         |
| ----------- | -------------------------------------------- |
| GL_ALWAYS   | 永远通过模板测试                             |
| GL_NEVER    | 永远不通过模板测试                           |
| GL_LESS     | 在片段深度值小于缓冲的深度值时通过测试       |
| GL_EQUAL    | 在片段深度值等于缓冲区的深度值时通过测试     |
| GL_LEQUAL   | 在片段深度值小于等于缓冲区的深度值时通过测试 |
| GL_GREATER  | 在片段深度值大于缓冲区的深度值时通过测试     |
| GL_NOTEQUAL | 在片段深度值不等于缓冲区的深度值时通过测试   |
| GL_GEQUAL   | 在片段深度值大于等于缓冲区的深度值时通过测试 |



```c++
// 控制模版测试成功或失败后，对 stencil buffer 的处理
glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)
```

- `sfail`：模板测试失败时采取的行为。
- `dpfail`：模板测试通过，但深度测试失败时采取的行为。
- `dppass`：模板测试和深度测试都通过时采取的行为。

| 行为         | 描述                                               |
| ------------ | -------------------------------------------------- |
| GL_KEEP      | 保持当前储存的模板值                               |
| GL_ZERO      | 将模板值设置为0                                    |
| GL_REPLACE   | 将模板值设置为glStencilFunc函数设置的`ref`值       |
| GL_INCR      | 如果模板值小于最大值则将模板值加1                  |
| GL_INCR_WRAP | 与GL_INCR一样，但如果模板值超过了最大值则归零      |
| GL_DECR      | 如果模板值大于最小值则将模板值减1                  |
| GL_DECR_WRAP | 与GL_DECR一样，但如果模板值小于0则将其设置为最大值 |
| GL_INVERT    | 按位翻转当前的模板缓冲值                           |



















