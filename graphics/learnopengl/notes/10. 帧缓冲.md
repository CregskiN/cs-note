# 帧缓冲

帧缓冲 FrameBuffer = 颜色缓冲 + 深度缓冲 + 模版缓冲



```c++
unsigned int fbo;
// 创建帧缓冲
glGenFramebuffers(1, &fbo);

// 绑定帧缓冲
glBindFramebuffer(GL_FRAMEBUFFER, fbo); // 从此所有对帧缓冲的 read、write 都会影响这个被绑定的帧缓冲
/*
	也可以使用 GL_READ_FRAMEBUFFER 或 GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标
	绑定到 GL_READ_FRAMEBUFFER 的帧缓冲将会使用在所有像是 glReadPixels 的读取操作中
	而绑定到 GL_DRAW_FRAMEBUFFER 的帧缓冲将会被用作渲染、清除等写入操作的目标
	大部分情况你都不需要区分它们，通常都会使用 GL_FRAMEBUFFER，绑定到两个上
*/
```

一个完整的帧缓冲需要满足以下的条件：

- 附加至少一个缓冲（颜色、深度或模板缓冲）。
- 至少有一个颜色**附件**(Attachment)。
- 所有的附件都必须是完整的（保留了内存）。
- 每个缓冲都应该有相同的样本数。

```c++
// 检查帧缓冲是否完整
if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)
  // shding
```

**这时，所有的渲染操作会应用到当前绑定的（自建）帧缓冲的附件中**

```c++
// 切换回默认帧缓冲
glBindFramebuffer(GL_FRAMEBUFFER, 0);
// 删除自创的帧缓冲对象
glDeleteFramebuffers(1, &fbo);
```



# 为帧缓冲添加一些内容

一个完整的帧缓冲需要满足以下的条件：

- 附加至少一个缓冲（颜色、深度或模板缓冲）。
- 至少有一个颜色**附件**(Attachment)。
- 所有的附件都必须是完整的（保留了内存）。
- 每个缓冲都应该有相同的样本数。

## 附件

###  纹理附件

附件是一个内存位置，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。

能作为 Attachment 的有两种：

+ 纹理
+ 渲染缓冲对象(Renderbuffer Object)

```c++
unsigned int texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
/**
 * @param target 目标纹理，即 GL_TEXTURE_2D、GL_TEXTURE_3D、GL_TEXTURE_2D_ARRAY 或 GL_TEXTURE_CUBE_MAP
 * @param level 指定要加载的mip级别。第一个级别为0，后续的mip贴图级别递增
 * @param internalformat 纹理存储的内部格式
 * @param width 图像的像素宽度
 * @param height 图像的像素高度
 * @param border 在OpenGL ES中忽略，保留是为了兼容桌面的OpenGL，传入0
 * @param format 输入的纹理数据格式
 * @param type 输入像素数据的类型
 * @param pixels 包含图像的实际像素数据
 
 void glTexImage2D(
        GLenum target, GLint level, GLint internalformat,
        GLsizei width, GLsizei height, GLint border,
        GLenum format, GLenum type, const GLvoid *pixels)
 */

glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

需要注意的几点：

+ glTexImage2D 中设置纹理的宽高为屏幕的宽高（非必需）
+ 纹理的数据部分，传入 NULL，意思是仅分配内存，而不填充内容

```c++
// 将这个纹理作为颜色附件 color attachment 绑定到 framebuffer 上
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);
```

glFrameBufferTexture2D 有以下的参数：

- `target`：帧缓冲的目标（绘制、读取或者两者皆有）
- `attachment`：附件类型。当前我们正在附加一个颜色附件。注意最后的`0`意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。
- `textarget`：你希望附加的纹理类型
- `texture`：要附加的纹理本身
- `level`：多级渐远纹理的级别。我们将它保留为0。



### 渲染缓冲对象 Renderbuffer Object

渲染缓冲对象是一个缓冲，可以作为附件的缓冲（另一个可作为附件的是纹理）

RBO 有几个特点：

+ 将数据存储为 OpenGL 原生渲染格式，为离屏渲染到帧缓冲优化
+ 可以操作 RBO 实现 glfwSwapBuffers 
+ 只写。一般用作 Depth buffer、Stencil buffer。与纹理那种通用数据缓冲不同的是，RBO 是专门设计用作于帧缓冲附件的

```c++
unsigned int rbo;
glGenRenderbuffers(1, &rbo);
glBindRenderbuffer(GL_RENDERBUFFER, rbo);
// 创建一个深度-模版 renderbuffer object
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600);
// 附加这个 RBO 到 framebuffer
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);
```

> 渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。



## 缓冲 - 深度缓冲、模版缓冲

以纹理的形式，将缓冲附加到 framebuffer 上

```c++
// 单独将深度缓冲附加 framebuffer
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 800, 600, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, texture, 0);

// 单独将模版缓冲附加到 framebuffer
// 这里 glTexImage2D internalformat 参数可能不对
glTexImage2D(GL_TEXTURE_2D, 0, GL_STENCIL_INDEX, 800, 600, 0, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, NULL);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0);
```



下为将深度缓冲和模版缓冲附加为一个单独纹理的代码：

纹理的 32bit，其中 24bit 分配给 Depth Value、8bit 分配给 Stencil Value。

```c++
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);

glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0);
```

















