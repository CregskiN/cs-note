本文首发于

# 0. 背景介绍

很多 **顶点着色器 ( vertex shader)** 中都用到**法线矩阵 ( normal matrix )**。本文内容涉及法线矩阵是什么、法线矩阵有什么用。本节内容，受 Eric Lengyel 所著《Mathematics for 3D Programming and Computer Graphics》的启发。

有很多计算工作是在 **观测空间 ( eye space )** 下完成的，其中包括与光照相关的计算。如果不在观测空间计算，与观测位置相关的效果将很难实现，如高光 ( specular )。

因此，我们需要一种方法，将法线转换到观测空间。将顶点变换到观测空间的计算，可以写成：

```c_+
vertexEyeSpace = gl_ModelViewMatrix * gl_Vertex;
```

那为什么不能对法线做一遍同样的操作呢？法线是有 3 个浮点数分量的向量，*模型-观测矩阵* 是 4x4 的矩阵。法线是一个向量，我们只想改变其方向。*模型-观测矩阵* 左上区域的 3x3 矩阵包含改变方向的**子矩阵**，那我们为什么不直接用法向量左乘这个**子矩阵**？



# 1. 错误的做法与分析

这很容易通过下面的代码实现：

```c++
normalEyeSpace = vec3(gl_ModelViewMatrix * vec4(gl_Normal,0.0));
```

所以，*gl_NormalMatrix* 只是一个简化或优化代码编写的捷径？不，不是的。上面一行代码只在某些情况下有效。

让我们看看潜在的问题：

<img src="https://www.qiniu.cregskin.com/202203082141882.png" alt="image-20220308214101825" style="zoom:50%;" />

上图中，有一个三角形，一条法向量，一条切向量。下图，将展示当 *模型-观测矩阵* 包含非均匀的缩放时，会发生什么。

<img src="https://www.qiniu.cregskin.com/202203082143414.png" alt="image-20220308214321390" style="zoom:50%;" />

> 注意：如果缩放是均匀的，法线的方向将保持不变，长度会受影响，但很容易通过单位化修复

如果上图的 *模型-观测矩阵* 被应用到所有顶点和法线，显然会得到错误的结果：**法线将不再垂直于平面**。

我们知道，向量可以用两个点的差表示。比如切向量，可以通过三角形边上的两个顶点做差得到。如果 $P_1$ 和 $P_2$ 就是定义在三角形边上的两个顶点，可以得到：

$ \vec{T} = P_2 - P_1$

考虑到在齐次坐标中，向量可以用含四个分量的元组表示 ( 最后一个分量为 0 )，可以让等号两侧同时左乘 *模型-观测矩阵*：

$modelView * \vec{T} = modelView * (P_2 - P_1)$

化简成：

$modelView * \vec{T} = modelView * P_2 - modelView * P_1$

$\vec{T'} = P_2' - P_1'$

因为 $P_1'$ 和 $P_2'$ 是变换后三角形边上的顶点，所以 $\vec{T'}$ 仍然是三角形边上的切向量，故可以认为：*模型-变换矩阵* 保留了切向量，却没有保留法向量。



# 2. 改进与推导

考虑对向量 $\vec{T}$ 采用的方法，我们可以假设两个顶点，如下：

$\vec{N} = Q_2 - Q_1$

主要的问题如之前图中展示的那样，通过变换后的点定义的向量 $Q_2' - Q_1'$ 不一定保持原样 ( 原来是垂直于三角形面的 )。法向量不像切向量那样，通过两个点做差定义，而只定义为一个垂直于平面的向量。



所以，我们明白了，不能简单地把 *模型-观测矩阵* 应用于所有情况下的法向量。那问题来了，我们应该用啥样的矩阵呢？



考虑一个 3x3 的矩阵 $G$ ，然后我们来看看这个矩阵如何计算，并完美地转换法向量。

在变换前后，$\vec{T}$ 和 $\vec{N}$ 都是垂直的，因此在变换前，满足 $T \cdot N = 0$ ，变换后还满足 $T' \cdot N' = 0$ 。切向量 $\vec{T}$ 可以安全地左乘 *模型-观测矩阵* 左上方的 3x3 子矩阵 ( $T$ 是一个齐次坐标下的向量，w 分量为 0 )，我们把这个子矩阵称为 $M$

假设矩阵 $G$ 能正确的转换法向量 $\vec{N}$ ，得出等式：

$N' \cdot T' = (G\vec{N}) \cdot (M\vec{T}) = 0$

**向量点积等价于对应分量乘积之和**，得：

$(G\vec{N}) \cdot (M\vec{T}) = (G\vec{N})^T * (M\vec{T})$

> 注意：第一个向量必须转置，以便计算对应分量乘积之和

我们还知道，乘法的转置，就是转置的乘法，即：

$(G\vec{N})^T * (M\vec{T}) = N^T G^T M \vec{T}$

首先声明，$\vec{N} \cdot \vec{T} = 0$，所以如果有：

$G^T M = I$

那就能满足我们的声明：

$\vec{N'} \cdot \vec{T'} = \vec{N} \cdot \vec{T} = 0$

所以通过 $M$ 反推出 $G$ ：

$G^TM = I \iff G = (M^{-1})^T$



# 3. 总结

因此，能正确转换法向量的矩阵，就是 $M$ 的逆的转置。OpenGL 在 *gl_NormalMatrix* 中进行这步计算。

在本节开始提到，在某些情况下，*模型-变换矩阵* 可以直接应用于法向量的变换，即当 *模型-观测矩阵* 是正交矩阵时：

$M^{-1} = M^T \Longrightarrow G = M$

对于正交矩阵，其转置等于其逆。那什么是正交矩阵呢？一个正交矩阵，任意的行/列都是单位长度，且互相垂直。两个向量分别乘正交矩阵后的夹角，与变换前是一致的。简单地说，变换保留了向量之间的角度关系，因此变换后的法线与切线仍互相垂直！此外，还保留了向量的长度。

那我们如何能确定 M 是正交矩阵呢？当我们的变换中，只包含旋转和平移，即在 OpenGL 中，我们只使用 glRotate 和 glTranslate，而不使用 glScale。这样操作能保证 M 是正交的。注意： gluLookAt 也创建了一个正交矩阵！



References:

[The Normal Matrix » Lighthouse3d.com](http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/)















