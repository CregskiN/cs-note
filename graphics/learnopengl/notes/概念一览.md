[TOC]





# 1. 概念

## VAO、VBO、IBO

+ 顶点缓冲对象(Vertex Buffer Objects, VBO)

  在 GPU 显存创建并管理 buffer，以存储成批的 Vertex data

  + `glGenBuffers(1, unsigned int&VBO)` 生成一个 VBO 对象

  + `glBindBuffer(GL_ARRAY_BUFFER, VBO_id)` 把 VBO 绑定到 GL_ARRAY_BUFFER 目标上

  + `glBufferData()` 把用户的顶点数据，复制到 GL_ARRAY_BUFFER 中

    ![img](https://www.qiniu.cregskin.com/202203041819968.png)

    > 链接顶点属性：把顶点 buffer 中的数据，与 vertex shader 输入的顶点对应起来
    >
    > **当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)**
    >
    > + `glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0)` 设置 OpenGL 解析当前 buffer 中每个顶点数据的方式
    >   + location = 0，对应用 layout(location = 0) 的 vertex shader 处理
    >   + 对应 shader 中**顶点属性** vec3 的分量个数
    >   + 数据类型
    >   + 是否希望标准化
    >   + 步长
    >   + 位置数据在 buffer 中的偏移量
    > + `glEnableVertexAttribArray(0)`

  ```c++
  // 0. 复制顶点数组到缓冲中供OpenGL使用
  glBindBuffer(GL_ARRAY_BUFFER, VBO);
  glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
  // 1. 设置顶点属性指针
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
  glEnableVertexAttribArray(0);
  // 2. 当我们渲染一个物体时要使用着色器程序
  glUseProgram(shaderProgram);
  // 3. 绘制物体
  someOpenGLFunctionThatDrawsOurTriangle();
  ```

  > 假设每个物体的顶点用一个 vertex shder 处理，当物体非常多时，需要以上的代码需要针对不同物体分别设置、调用。是否有一种方法，将每个物体的配置都保留以复用
  >
  > Vertex Array Object 储存每个顶点属性的配置、调用，以复用



- **顶点数组对象：Vertex Array Object，VAO**

  一个顶点数组对象会储存以下这些内容：

  - `glEnableVertexAttribArray` 和 `glDisableVertexAttribArray` 的调用
  - 通过 `glVertexAttribPointer` 设置的顶点属性配置
  - 通过 `glVertexAttribPointer` 调用与顶点属性关联的顶点缓冲对象

  <img src="https://www.qiniu.cregskin.com/202203042148538.png" alt="image-20220304214857506" style="zoom:50%;" />

  

  

- 顶点缓冲对象：Vertex Buffer Object，VBO

  

  Vertex data 需要添加到 GL_ARRAY_BUFFER 中，积累到一定量，一次发送到 GPU 显存，交给 Vertex Shader 处理。我们使用 VBO 管理这个 GL_ARRAY_BUFFER

  + `glGenBuffers(int不知道是啥, &ID)` 创建 VBO 对象 ID

  + `glBindBuffer(缓冲类型, VBO)` 设置 VBO 管理 buffer 的缓冲类型

  + `glBufferData(目标缓冲类型, unsigned int顶点数据大小单位字节, 顶点数据指针, GPU管理数据的方式)`

    GPU 管理数据的方式包括：

    - GL_STATIC_DRAW ：每次渲染时，数据不会或几乎不会改变
    - GL_DYNAMIC_DRAW：每次渲染时，数据会被改变很多
    - GL_STREAM_DRAW ：每次渲染时，数据每次绘制时都会改变

  > 顶点缓冲类型：GL_ARRAY_BUFFER

  ![img](https://www.qiniu.cregskin.com/202203041028837.png)

- 索引缓冲对象：Element Buffer Object，EBO 或 Index Buffer Object，IBO

  + 

  + 

    



## 图形渲染管线（Graphics Pipeline）

分两个部分：第一部分把3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素

<img src="http://127.0.0.1:8000/img/01/04/pipeline.png" alt="img" style="zoom:100%;" />

+ **顶点着色器(Vertex Shader)** 

  `input`：Vertex Data（包括位置、颜色等信息）

  `output`：处理后的 Vertex Data

  处理内容包括：3D 坐标变换（标准化设备坐标）、顶点基本属性

  

+ **图元装配(Primitive Assembly)** 

  `input`：Vertex Data

  `output`：图元 Primitive 形式的顶点集合

  处理内容包括：将顶点按照指定的图元，装配

  > **图元（Primitive）**
  >
  > 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做**图元(Primitive)** 
  >
  > GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP

  

+  **几何着色器(Geometry Shader)**

  `input`：图元形式的顶点集合

  `output`：新的形状

  使用前一阶段输出的图元，或通过生成新的图元，构成新的形状

  

+ **光栅化阶段(Rasterization Stage)**

  `input`：形状

  `output`：fragment

  将形状映射成像素片段 fragment

  

+ **片段着色器(Fragment Shader)**

  `input`：fragment

  `output`：计算 fragment 最终颜色

  处理过程包括：

  1. 裁切，将视口以外的像素丢弃

  2. 通过 3D 场景数据，如光照、阴影、光的颜色等计算最终颜色

     

+ **Alpha测试和混合(Blending)阶段**

  `z-buffer`：判断像素的前后位置，决定最终在屏幕上显示哪个像素

  `alpha 检查`：检查前后物体的透明度

  `blend 混合`：将透明度不同的像素混合，最终呈现到屏幕像素上

  

## 着色器 Shader

+ `glCreateShader(Shader类型)`

  Shader 类型包括 GL_VERTEX_SHADER

+ `glShaderSource(shader指针, int源码字符串数量, &GLSL源码, NULL)`

+ `glCompileShader()`

```c++
const char* vertexShaderSource =
  "#version 330 core\n"
  "layout (location = 0) in vec3 aPos;\n"
  "void main()\n"
  "{\n"
  "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
  "}\0";
unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);  // 创建 Shader
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);    // 传递 GLSL
glCompileShader(vertexShader);                                 // 编译 Shader
```







## 其他概念

### 标准化设备坐标(Normalized Device Coordinates)

$(x, y, z) \in [-1, 1]^3$ 

NDC 经过视口变换，变成屏幕空间坐标(Screen-space Coordinates)，输入到 Fragment Shader

![ndc](https://www.qiniu.cregskin.com/202203032225444.png)

# 2. 函数

颜色

+ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // 设置颜色状态
+ glClear(缓冲位)
  + GL_COLOR_BUFFER_BIT、GL_DEPTH_BUFFER_BIT、GL_STENCIL_BUFFER_BIT

