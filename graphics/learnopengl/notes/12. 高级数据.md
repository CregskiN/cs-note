# 高级数据

## 更多管理缓冲的方式

```c++
unsigned int buffer;
glGenBuffers(1, &buffer);
glBindBuffer(GL_ARRAY_BUFFER, buffer);

// 全部填充 buffer
glBufferData(GL_ARRAY_BUFFER, sizeof(data), &data, GL_STATIC_DRAW);
// 部分填充 buffer
glBufferSubData(GL_ARRAY_BUFFER, offset, sizeof(data), &data); // 填充范围 [24, 24+sizeof(data)]
// 获取 buffer 的指针
void *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
memcpy(ptr, data, sizeof(data));
glUnmapBuffer(GL_ARRAY_BUFFER); // 解绑 buffer 内存指针
/*
	如果要直接映射数据到缓冲，而不事先将其存储到临时内存（临时变量）中，glMapBuffer这个函数会很有用
	比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。
*/
```



## 分批布局顶点属性

更改 ARRAY_BUFFER 中数据的布局（交错布局 to 分批布局）

```c++
float positions[] = { ... };
float normals[] = { ... };
float tex[] = { ... };
// 填充缓冲
glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &positions);
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &normals);
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &tex);
// 更新对应的顶点属性
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);  
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions)));  
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals)));
```



## 复制缓冲

+ glCopyBufferSubData

```c++
void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
```

+ `readtarget` 源
+ `writetarget` 目标

出现问题：如果想读取、写入的都是 GL_ARRAY_BUFFER，这两个参数不能都写作 GL_ARRAY_BUFFER 的

解决方案：GL_COPY_READ_BUFFER、GL_COPY_WRITE_BUFFER

```c++
float vertexData[] = { ... };
glBindBuffer(GL_COPY_READ_BUFFER, vbo1);
glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);
glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));
```

或者还是从 ARRAY_BUFFER 中读取，只是暂时写入到 GL_COPY_WRITE_BUFFER

```c++
float vertexData[] = { ... };
glBindBuffer(GL_ARRAY_BUFFER, vbo1);
glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);
glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));
```















