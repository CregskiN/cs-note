## 1. 概念

特点：把类或接口转换成另一个接口以便系统调用。

用处：当系统需要引入多个功能类并且这些功能的接口不统一时可以考虑用适配器模式把它们转成统一的接口，现实中的例子很多，比如充电器接口适配器。

注意：分为对象适配器和类适配器。



## 5. 适配器模式的优缺点

适配器模式的优点：

1. 已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到**更好的复用**，有助于避免大规模改写现有代码；
2. **可扩展性良好**，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；
3. **灵活性好**，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；

适配器模式的缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对**可阅读性不太友好**。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。



```typescript

interface Graph {
    drawLine: () => void;
    drawPie: () => void;
}

class Canvas2D implements Graph {
    drawLine() {
        console.log('draw 2d line');
    }
    drawPie() {
        console.log('draw 2d pie');
    }
}


class Canvas3D {
    draw3DLine() {
        console.log('draw 3d line');
    }

    draw3DPie() {
        console.log('draw 3d pie');
    }
}

class Canvas3DAdapter implements Graph {
    private canvas3D: Canvas3D = new Canvas3D();

    drawLine() {
        this.canvas3D.draw3DLine();
    }

    drawPie() {
        this.canvas3D.draw3DPie();
    }
}

let canvas2D: Graph = new Canvas2D();
canvas2D.drawLine();
canvas2D.drawPie();

let canvas3D: Graph = new Canvas3DAdapter();
canvas3D.drawLine();
canvas3D.drawPie();
```





## 6. 适配器模式的适用场景

当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。

1. 如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口；
2. 如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么；



## 7. 其他相关模式

适配器模式和代理模式、装饰者模式看起来比较类似，都是属于包装模式，也就是用一个对象来包装另一个对象的模式，他们之间的异同在代理模式中已经详细介绍了，这里再简单对比一下。



### 7.1 适配器模式与代理模式

1. **适配器模式：** 提供一个不一样的接口，由于原来的接口格式**不能用了**，提供新的接口以满足新场景下的需求；
2. **代理模式：** 提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；



### 7.2 适配器模式、装饰者模式与代理模式

1. **适配器模式：** 功能不变，只转换了原有接口访问格式；
2. **装饰者模式：** 扩展功能，原有功能不变且可直接使用；
3. **代理模式：** 原有功能不变，但一般是经过限制访问的；