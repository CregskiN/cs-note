> 虚拟代理：文件口袋初始化，检查缓存和用户登录状态部分
>
> 

## 1. 概念

**代理模式** （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。

代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。



> 代理模式与外观模式的差别在于：
> 代理和被代理使用同一抽象，并且代理着重于访问控制。
> 外观则着重于简化原本复杂的操作，并在此基础上提取新抽象。

> 代理模式与装饰器模式的差别在于：
> 代理的目的一般不是为了增加新功能而在于访问控制，同时代理通常是自己来创建被代理对象。
> 装饰器则着重于增加新功能，且被装饰对象通常是作为引用传给装饰器的。



## 2. 本地代理

```typescript
// 数据接口
interface DataService {
    getData: () => string | Promise<string>;
}

// server 服务
class RemoteService implements DataService {
    getData() {
        return 'get remote data.';
    }
}

class Requester {
    Request(): Promise<string> {
        return Promise.resolve(new RemoteService().getData());
    }
}

// 本地代理
class DataProxy implements DataService {
    async getData(): Promise<string> {
        return await new Requester().Request();
    }
}
/**
 * DataProxy和远程的RemoteService使用同样的接口，
 * client像调用本地功能一样通过DataProxy使用远程功能。
 */
let dataService: DataService = new DataProxy();
let data = dataService.getData();

if (data instanceof Promise) {
    data.then(o => console.log(o));
} else {
    console.log(data);
}
```





## 4. 代理模式在实战中的应用

### 4.1 拦截器

上一小节使用代理模式代理对象的访问的方式，一般又被称为**拦截器**。

拦截器的思想在实战中应用非常多，比如我们在项目中经常使用 Axios 的实例来进行 *HTTP* 的请求，使用拦截器 `interceptor` 可以提前对 `request` 请求和 `response` 返回进行一些预处理，比如：

1. `request` 请求头的设置，和 Cookie 信息的设置；
2. 权限信息的预处理，常见的比如验权操作或者 Token 验证；
3. 数据格式的格式化，比如对组件绑定的 `Date` 类型的数据在请求前进行一些格式约定好的序列化操作；
4. 空字段的格式预处理，根据后端进行一些过滤操作；
5. `response` 的一些通用报错处理，比如使用 Message 控件抛出错误；



### 4.2 前端框架的数据响应式化

为什么 Vue 2.x 到 3.x 要从 `Object.defineProperty` 改用 `Proxy` 呢，是因为前者的一些局限性，导致的以下缺陷：

1. 无法监听利用索引直接设置数组的一个项，例如：`vm.items[indexOfItem] = newValue`；
2. 无法监听数组的长度的修改，例如：`vm.items.length = newLength`；
3. 无法监听 ES6 的 `Set`、`WeakSet`、`Map`、`WeakMap` 的变化；
4. 无法监听 `Class` 类型的数据；
5. 无法监听对象属性的新加或者删除；

除此之外还有性能上的差异，基于这些原因，Vue 3.x 改用 `Proxy` 来实现数据监听了。当然缺点就是对 IE 用户的不友好，兼容性敏感的场景需要做一些取舍。



### 4.3 缓存代理

备忘模式就是使用缓存代理的思想，将复杂计算的结果缓存起来，下次传参一致时直接返回之前缓存的计算结果。



### 4.4 保护代理和虚拟代理

有的书籍中着重强调代理的两种形式：**保护代理**和**虚拟代理**：

1. **保护代理** ：当一个对象可能会收到大量请求时，可以设置保护代理，通过一些条件判断对请求进行过滤；
2. **虚拟代理** ：在程序中可以能有一些代价昂贵的操作，此时可以设置虚拟代理，虚拟代理会在适合的时候才执行操作。

![图片描述](https://img1.sycdn.imooc.com/5d1322290001ebb707260192.gif)



### 4.5 正向代理与反向代理

还有个经常用的例子是**反向代理**（Reverse Proxy），反向代理对应的是**正向代理**（Forward Proxy），他们的区别是：

1. **正向代理：** 一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；
2. **反向代理：** 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。

反向代理一般在处理跨域请求的时候比较常用，属于服务端开发人员的日常操作了，另外在缓存服务器、负载均衡服务器等等场景也是使用到代理模式的思想。



![图片描述](https://img1.sycdn.imooc.com/5d1322580001157509240996.png)



## 5. 代理模式的优缺点

代理模式的主要优点有：

1. 代理对象在访问者与目标对象之间可以起到**中介和保护目标对象**的作用；
2. 代理对象可以**扩展目标对象的功能**；
3. 代理模式能将访问者与目标对象分离，在一定程度上**降低了系统的耦合度**，如果我们希望适度扩展目标对象的一些功能，通过修改代理对象就可以了，符合开闭原则；

代理模式的缺点主要是增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（**十八线明星就别请经纪人了**）。



## 6. 其他相关模式

很多其他的模式，比如状态模式、策略模式、访问者模式其实也是使用了代理模式，包括在之前高阶函数处介绍的备忘模式，本质上也是一种缓存代理。



### 6.1 代理模式与适配器模式

代理模式和适配器模式都为另一个对象提供间接性的访问，他们的区别：

1. **适配器模式：** 主要用来解决接口之间不匹配的问题，通常是为所适配的对象提供一个不同的接口；
2. **代理模式：** 提供访问目标对象的间接访问，以及对目标对象功能的扩展，一般提供和目标对象一样的接口；



### 6.2 代理模式与装饰者模式

装饰者模式实现上和代理模式类似，都是在访问目标对象之前或者之后执行一些逻辑，但是目的和功能不同：

1. **装饰者模式：** 目的是为了方便地给目标对象添加功能，也就是动态地添加功能；
2. **代理模式：** 主要目的是控制其他访问者对目标对象的访问；



### 6.3 代理模式与外观模式的差别在于：
代理和被代理使用同一抽象，并且代理着重于访问控制。
外观则着重于简化原本复杂的操作，并在此基础上提取新抽象。