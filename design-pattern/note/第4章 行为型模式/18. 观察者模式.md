## 1. 概念

特点：定义了对象间的一对多关系，当对象状态改变时，其他订阅了这个对象的对象就会收到通知。

用处：当一个对象状态的改变时需要其他对象也做出响应时可以考虑观察者模式，如网络聊天里的群。

注意：与中介者的区别。



## 2. typescript

场景：聊天室Group，记录所有用户信息userList，每次用户调用sendMsg，间接调用Group的sendMsg，间接调用Group的notify，然后遍历Group存储的userList，调用每个元素的receiveMsg，由此实现每个成员收到消息

```typescript
interface Observer {
    name: string;

    sendMsg(msg: string): void;
    receiveMsg(sender: Observer, msg: string): void;
}

interface Subject {
    register(observer: Observer): void;
    unregister(observer: Observer): void;
    sendMsg(sender: Observer, msg: string): void;
}


// 用户类
class User implements Observer {
    public name: string;
    private subject: Subject;

    constructor(name: string, subject: Subject) {
        this.name = name;
        this.subject = subject;
    }

    public sendMsg(msg: string) {
        console.log(`${this.name} 发送了消息，${msg}`);
        this.subject.sendMsg(this, msg);
    }

    public receiveMsg(sender: Observer, msg: string) {
        console.log(`${this.name} 收到来自 ${sender.name} 的消息，${msg}`);
    }
}

// 群组
class Group implements Subject {
    private userList: Observer[];

    constructor() {
        this.userList = [];
    }

    register(observer: Observer) {
        this.userList.push(observer);
    }

    unregister(observer: Observer) {
        const index = this.userList.indexOf(observer);
        if (index > -1) {
            this.userList.splice(index, 1);
        }
    }

    sendMsg(sender: Observer, msg: stirng) {
        console.log(`群组收到${sender.name} 发来的消息，${msg} 通知所有人`);
        this.notify(sender, msg);
    }

    /**
     * 发布通知
     * @param sender 
     * @param msg 
     */
    private notify(sender: Observer, msg: string) {
        this.userList.forEach(user => {
            user.receiveMsg(sender, msg);
        })
    }
}

let group = new Group();
let jim = new User('jim', group);
let brook = new User('brook', group);
let lucy = new User('lucy', group);

jim.sendMsg('hello');
lucy.sendMsg('well done!');
```

