# 1. 范型算法

只读算法

+ **find(container.cbegin(), container.cend(), value)**

  查值，使用元素 ==

+ **accumblate(vec1.cbegin(), vec1.cend(), vec2.begin(), value)**

  累加到 value，使用元素 +

+ **equal(vec1.cbegin(), vec1.cend(), vec2.cbegin())**

  两序列比较，使用元素 ==

写容器算法

+ **fill(vec.begin(), vec.end(), value)**

  填充value 

+ **fill_n(vec.begin(), int size, value)**

  另一种形式的填充value 

+ **back_inserter(Container vec)**

  返回插入迭代器，赋值调用push_back()

+ **copy(vec1.begin(), vec1.end(), vec2)**

  将 vec1 中一段元素，复制到 vec2（容量 vec2 >= vec1）

+ **replace(vec1.begin(), vec2.end(), old_value, new_value)**

  搜索所有 old_value 全部替换为 new_value

+ **replace_copy(vec1.begin(), vec1.end(), vec2.begin(), old_value, new_value)**

  将 vec1 [begin, end) 范围内元素，复制到 vec2，并搜索所有 old_value 全部替换为 new_value

重排元素算法

+ **std::iterator unique(vec.begin(), vec.end())**

  重复的元素中，只留下一个。返回 end 迭代器
  
+ **unique_copy(vec1.begin(), vec1.end(), vec2.begin())**

  将 vec1 [begin, end) 范围内元素，去除重复元素后，复制到 vec2 begin 位置

定制算法

+ **sort(vec.begin(), vec.end(), 回调函数)**

  依次对 vec 前后元素执行回调函数，并根据回调函数的返回值确定顺序。true 顺序不变，false 前后调换

+ **stable_sort(vec.begin(), vec.end(), 回调函数)**

  sort 的稳定版本

+ **find_if(vec.begin(), vec.end(), 回调函数)**

  返回 [begin, end) 范围内，第一个使回调函数返回 1 的元素的迭代器

+ **for_each(vec.begin(), vec.end(), 回调函数)**

  对 [begin, end) 元素执行回调函数

+ **transform(vec.begin(), vec.end(), 目的位置迭代器, 回调函数)**

  对 [begin, end) 范围元素执行回调函数，并将结果依次写入到目的位置



# 2. 迭代器

插入迭代器

+ **back_inserter(vec)**

  创建一个使用 push_back 的迭代器，赋值行为会被替代成 push_back

+ **front_inserter(vec)**

  创建一个使用 push_front 的迭代器，赋值行为会被替代成 push_front

+ **inserter(vec, 目标位置迭代器)**

  创建一个使用 insert 的迭代器，赋值会被插入到目标位置之前

+ 



# 3. 特定容器算法

链表 list、forward_list 成员函数

+ list1.merge(list2)

  将有序链表 list2 合并到 list1，结束后 list2 为空。使用 <

+ list1.merge(list2, comp)

  将有序链表 list2 合并到 list1，结束后 list2 为空。使用 comp

+ list.remove(value)

+ list.remove_if(回调函数)

  删除第一个使回调函数返回 true 的元素。使用 ==

+ list.reverse()

  逆转链表

+ list.sort()

+ list.sort(comp)

+ list.unique()

+ list.unique(回调函数)